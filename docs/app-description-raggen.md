# 1. Multimodal RAG RU

**Multimodal RAG RU** — это веб-приложение, использующее подход Retrieval-Augmented Generation (RAG) для обработки текстовых запросов. Приложение сочетает в себе возможности языковых моделей и векторизации текста, что позволяет генерировать более точные и контекстуализированные ответы на запросы пользователей. Пользователи могут выбирать провайдеров языковых моделей, таких как Yandex GPT и GigaChat, для генерации текста, а также использовать функционал RAG для улучшения качества ответов за счет использования дополнительного контекста из векторной базы данных.

## 1.1 Основные функции MVP

На первом этапе разработки (MVP) приложение будет включать следующие ключевые функции:

### 1.1.1 Выбор провайдера модели
   - Приложение поддерживает выбор между несколькими провайдерами языковых моделей. На старте доступны следующие:
     - **Yandex GPT**: Провайдер от Яндекса для генерации текста.
     - **GigaChat**: Еще один провайдер для обработки запросов и генерации ответов.
   
   Пользователи могут выбрать одного из этих провайдеров в интерфейсе для работы с их языковой моделью.

### 1.1.2 Обработка текстовых запросов
   - Приложение принимает текстовые запросы от пользователей.
   - Запросы передаются в выбранную языковую модель для генерации ответа на основе контекста.
   - Ответы генерируются с учетом того, какие данные были загружены и обработаны в приложении.
   
### 1.1.3 Векторизация текста и контекстная обработка
   - Приложение поддерживает загрузку текстовых файлов или текста для последующей векторизации.
   - Тексты преобразуются в векторное представление с использованием алгоритмов эмбеддинга, что позволяет искать и использовать контекст для формирования более точных и релевантных ответов.
   - Результаты векторизации сохраняются в базе данных, что обеспечивает возможность быстрой и эффективной работы с контекстом.

### 1.1.4 Управление историей чатов
   - Приложение ведет историю взаимодействий пользователей с языковыми моделями.
   - История чатов может быть использована для создания контекста для следующих запросов или для анализа предыдущих взаимодействий.

### 1.1.5 Интерфейс для управления параметрами генерации текста
   - Пользователи могут настраивать параметры генерации текста, такие как температура, длина ответа и другие параметры, доступные для провайдеров моделей.

## 1.2 Планируемые релизы

### 1.2.1 Выделение сервиса на Python для работы с эмбеддингами
   - На текущий момент эмбеддинги обрабатываются в основном бэкенде (Node.js), но в будущем планируется выделить отдельный сервис на Python для работы с эмбеддингами.
   - Этот сервис будет отвечать за создание и хранение векторных представлений текста, а также за обработку запросов к векторной базе данных.
   - Разделение сервисов улучшит масштабируемость приложения и обеспечит лучшую производительность при работе с большими объемами данных.

### 1.2.2 Подключение дополнительных провайдеров языковых моделей
   - В будущих релизах приложение будет интегрировать дополнительные языковые модели и провайдеров, таких как OpenAI и другие, для расширения возможностей генерации текста.
   - Пользователи смогут выбирать не только между Yandex GPT и GigaChat, но и использовать другие модели для более разнообразных ответов и задач.

### 1.2.3 Расширенные возможности RAG
   - В следующей версии будет улучшена работа с Retrieval-Augmented Generation (RAG). Мы будем внедрять более сложные методы поиска контекста, что позволит получать более точные и релевантные результаты.
   - Использование разных моделей для генерации ответов будет зависеть от контекста запроса, что обеспечит более персонализированные ответы на основе контекстной информации.

### 1.2.4 Интерфейс для разработки и тестирования моделей
   - В будущем будет добавлен интерфейс для разработки и тестирования собственных языковых моделей, который позволит пользователям кастомизировать модели и тестировать их в реальных условиях.

# 2. Технологический стек для проекта **Multimodal RAG RU**

## 2.1 Frontend

### 2.1.1 Next.js
- Используется для серверного рендеринга и создания динамических страниц.
- Обеспечивает улучшенное SEO и производительность приложения.
- **API Routes** в Next.js обеспечат серверную логику для работы с запросами от пользователя, такими как история чатов и отправка сообщений.

### 2.1.2 Tailwind CSS
- Применяется для быстрой стилизации интерфейсов, позволяя кастомизировать UI элементы.
- Позволяет быстро создавать адаптивные и кастомизированные компоненты интерфейса, такие как кнопки для загруз��и файлов и формы для настройки генерации текста.

## 2.2 Backend

### 2.2.1 Node.js
- Основной серверный язык для разработки логики приложения.
- Обрабатывает запросы от пользователей, взаимодействует с API провайдерами (Yandex GPT, GigaChat) и управляет пользовательскими данными.
- Взаимодействует с Python-сервисом для работы с эмбеддингами через REST API или WebSocket.

### 2.2.2 Prisma ORM
- Используется для работы с базой данных SQLite.
- Обеспечивает высокоуровневый доступ к данным и упрощает операции с БД, такие как создание записей чатов, пользователей и истории запросов.
- Обеспечивает интеграцию с Python-сервисом для хранения и синхронизации эмбеддингов.

### 2.2.3 SQLite
- Легковесная реляционная база данных для хранения данных чатов, пользователей и текстов.
- Хранит результаты векторизации текста (эмбеддингов) и историю чатов.
- Подходит для небольших и средних проектов, таких как ваше приложение, где нет необходимости в масштабируемой распределённой системе.

## 2.3 Эмбеддинг-сервис (Python)

### 2.3.1 Роль Python-сервиса
- Отвечает за векторизацию текста с использованием модели all-MiniLM-L6-v2 от HuggingFace
- Генерирует эмбеддинги для текста, загруженного пользователями, и сохраняет их в базе данных
- Интеграция с Node.js через REST API для передачи данных между сервисами

### 2.3.2 Интеграция с Node.js
- Python-сервис получает запросы от Node.js на векторизацию текста и возвращает результаты.
- Векторизация текста происходит в Python-сервисе, результаты (эмбеддинги) сохраняются в SQLite.
- Для поиска контекста используется система поиска по векторным данным, такая как **FAISS** или **Pinecone**.

## 2.4 API провайдеры

### 2.4.1 Yandex GPT и GigaChat API
- Оба провайдера языковых моделей используются для генерации текста на основе контекста, получаемого из векторной базы данных.
- **Yandex GPT** используется для работы с текстами на русском языке.
- **GigaChat** используется в качестве дополнительного провайдера для увеличения вариативности генерации.
- Контекст, полученный из базы данных, прикладывается к запросу, отправляемому в эти API для получения более релевантных ответов.

## 2.5 Развёртывание

### 2.5.1 Yandex Cloud / Sber Cloud
- Для хостинга бэкенд-сервисов (Node.js и Python).
- Облачные платформы предоставляют необходимые ресурсы для масштабируемости и обработки данных с низкими задержками.
- Интеграция с другими сервисами, такими как базы данных и API провайдеры.

### 2.5.2 Vercel / Netlify
- Для развертывания фронтенда. Vercel оптимизирован для Next.js и поддерживает автоматическое развертывание.
- Netlify может использоваться для статических сайтов и серверных функций, если потребуется интеграция API на фронтенде.

## 2.6 Векторная База Данных и Поиск

### 2.6.1 FAISS или Pinecone
- **FAISS** — это библиотека для поиска по векторным данным от Facebook.
- **Pinecone** — это облачный сервис для работы с векторными базами данных, обеспечивающий быстрый поиск и интеграцию.

Эти технологии будут использоваться для хранения эмбеддингов и поиска наиболее релевантных частей текста из базы данных на основе запросов пользователей.

# 3. Взаимодействие компонентов

- **Frontend** взаимодействует с **Node.js** через REST API для получения и отправки сообщений пользователям.
- **Node.js** обрабатывает запросы, управляет базой данных и взаимодействует с **Python-сервисом** для векторизации текста или получения контекста.
- **Python-сервис** генерирует эмбеддинги, сохраняет их в базу данных и использует FAISS или Pinecone для поиска контекста.
- Результаты поиска контекста отправляются в **Node.js**, который затем передает их в **Yandex GPT** или **GigaChat API** для генерации текста.
- Полученные ответы отправляются пользователю через **Frontend**.

# 4. Структура приложения

## 4.1 Главная страница

**Цель**: Предоставить пользователю интерфейс для общения с различными языковыми моделями, выбора модели и генерации текста.

### 4.1.1 Элементы
- **Выбор провайдера и модели**:
  - Провайдеры: Yandex GPT / GigaChat
  - Модели для каждого провайдера
- **Поле ввода текста с кнопкой отправки**:
  - Ввод текста пользователем для запроса модели.
  - Кнопка для отправки запроса.
- **Лента сообщений**:
  - История сообщений (вопросы пользователя и ответы моделей).
  - Автоматическое прокручивание до последнего сообщения.
- **Настройки генерации текста**:
  - Температура генерации
  - Максимальное количество токенов
- **Кнопка "Очистить чат"**:
  - Сброс контекста и истории сообщений.
- **Загрузка файлов**:
  - Возможность загрузки текстовых файлов для обработки.

## 4.2 Компоненты генерации страницы

### 4.2.1 Header
**Состав**:
- Логотип приложения
- Выбор провайдера (Yandex GPT / GigaChat)
- Выбор модели в зависимости от провайдера
- Переключатель темы (светлая/тёмная)

**Функциональность**:
- **Логотип**: Отображает логотип в верхней части страницы.
- **Выбор провайдера**: Позволяет пользователю выбрать провайдера языковой модели (Yandex GPT / GigaChat).
- **Выбор модели**: Динамически обновляется в зависимости от выбранного провайдера.
  - **Для Yandex GPT**:
    - YandexGPT Lite Latest (поколение 3)
    - YandexGPT Lite RC (поколение 4)
    - YandexGPT Pro Latest (поколение 3)
    - YandexGPT Pro RC (поколение 4)
    - YandexGPT Pro 32k RC (поколение 4)
  - **Для GigaChat**:
    - GigaChat
    - GigaChat-Pro
    - GigaChat-Max
- **Переключатель темы**: Позволяет пользователю переключать между светлой и тёмной темой.

**Взаимодействие с API**:
- При смене модели обновляется URI для запросов к соответствующему API провайдера.
- Выбранная модель сохраняется в состоянии приложения.
- Переключение темы работает локально.

### 4.2.2 Chat Window
**Состав**:
- История сообщений.
- Скроллинг до последнего ответа.

**Функциональность**:
- **История сообщений**: Отображает список сообщений, включая запросы пользователя и ответы модели.
  - Каждое сообщение имеет пометки, кто его отправил (пользователь или система).
- **Автоскроллинг**: Когда появляется новый ответ, окно автоматически скроллируется до последнего сообщения.

**Взаимодействие с API**:
- GET запрос на сервер для получения истории сообщений (метод `getChatHistory`).

### 4.2.3 Footer
**Состав**:
- Поле ввода текста.
- Кнопка отправки.
- Настройки генерации текста (например, параметры для GPT, такие как температура, максимальная длина ответа).
- **Загрузка файлов**: Возможность загрузки текстовых файлов для векторизации и обработки.

**Функциональность**:
- **Поле ввода текста**: Пользователь вводит текст запроса.
- **Кнопка отправки**: Отправляет запрос на сервер.
- **Настройки генерации текста**: Пользователь может настроить параметры генерации текста, такие как температура, длина ответа и другие.
- **Загрузка файлов**: Позволяет пользователю загружать текстовые файлы для обработки и анализа контекста.

**Взаимодействие с API**:
- POST запрос для отправки текста от пользователя.
- Сервер взаимодействует с выбранным API провайдера (например, Yandex GPT API или GigaChat API) для получения ответа.
- Ответ отображается в **Chat Window**.
- История сообщений и параметры генерации сохраняются в состоянии приложения или базе данных.
- Загруженные файлы передаются на сервер для дальнейшей обработки.

**Программная логика взаимодействия с API**:
1. Пользователь вводит текст в поле **Footer**.
2. Нажимает кнопку отправки, и приложение отправляет POST запрос (`sendMessage`) на сервер с текстом и параметрами генерации.
3. Загруженные файлы передаются на сервер для векторизации или обработки.
4. Сервер передает запрос на API провайдера (например, Yandex GPT или GigaChat), получает ответ и возвращает его в приложение.
5. Ответ от модели отображается в **Chat Window**.
6. История сообщений и параметры генерации сохраняются в базе данных или в локальном состоянии приложения.

## 4.3 Управление контекстом

### 4.3.1 Контекст чата
- Контекст чата сохраняется в базе данных, чтобы модель могла отвечать с учетом предыдущих сообщений.
- После завершения сессии чат можно сохранить или очистить по запросу пользователя.
- История сообщений может быть доступна для пользователей в рамках сессии или на постоянной основе для анализа.

**Функциональность**:
- Взаимодействие с базой данных для сохранения сообщений и настроек.
- Возможность очистки контекста чата (сброс истории).

## 4.4 Настройки генерации текста

### 4.4.1 Параметры генерации
- **Температура**: Контролирует степень случайности в ответах модели.
- **Максимальное количество токенов**: Ограничивает длину ответа от модели.
- **Темп вывода**: Модели можно настроить на более быстрые или более медленные ответы.

## 4.5 Взаимодействие с эмбеддингами и векторной базой данных

### 4.5.1 Векторизация текста
- Загружаемые текстовые файлы или текстовые данные пользователей вначале проходят векторизацию с использованием Python-сервиса.
- Эмбеддинги сохраняются в базе данных (SQLite или векторной базе данных).

### 4.5.2 Поиск контекста
- Когда пользователь отправляет запрос, система сначала обращается к базе данных для получения релевантного контекста на основе векторных данных.
- Этот контекст прикладывается к запросу и передается в API выбранного провайдера.

**Программная логика**:
1. Загруженный текст или данные векторизуются с помощью Python-сервиса.
2. Векторизированные данные сохраняются в базе данных.
3. Для поиска контекста используется FAISS или аналогичная система.
4. Ответ от модели генерируется с учетом контекста и возвращается пользователю.

# 5. Дизайн

## 5.1 Минималистичный и респонсивный интерфейс
Интерфейс приложения ориентирован на простоту и адаптированность под различные устройства, как мобильные, так и десктопные.

```css
/* Базовая настройка для адаптивного дизайна */
body {
  font-family: 'Roboto', sans-serif;
  margin: 0;
  padding: 0;
  background-color: var(--background-color);
  transition: background-color 0.3s ease-in-out;
}

@media (max-width: 768px) {
  body {
    padding: 10px;
  }
}
```

## 5.2 Цветовая палитра
Приложение поддерживает светлую и тёмную темы, которые легко переключаются через CSS переменные.

```css
/* Цветовая палитра */
:root {
  --light-background: #F2F2F2; /* Светлый фон */
  --dark-background: #2E2E2E; /* Темный фон */
  --button-primary: #A0A0A0; /* Основная кнопка */
  --button-hover: #808080; /* Цвет кнопки при наведении */
  --text-color: #333333; /* Цвет текста */
  --text-light: #B0B0B0; /* Светлый цвет текста */
  --accent-color: #6E6E6E; /* Акцентный цвет */
}

/* Светлая тема */
.light-theme {
  background-color: var(--light-background);
  color: var(--text-color);
}

/* Тёмная тема */
.dark-theme {
  background-color: var(--dark-background);
  color: var(--text-light);
}

/* Переключение темы */
.theme-toggle {
  background-color: var(--button-primary);
  color: #fff;
  border: none;
  border-radius: 30px;
  padding: 10px;
  cursor: pointer;
}

.theme-toggle:hover {
  background-color: var(--button-hover);
}
```

## 5.3 Шрифты
Используем шрифты Roboto или Open Sans для комфортного чтения текста, с разным весом шрифта для заголовков и основного контента.

```css
/* Шрифт для основного текста */
body {
  font-family: 'Roboto', sans-serif;
  font-weight: 400;
  color: var(--text-color);
}

/* Шрифт для заголовков */
h1, h2, h3 {
  font-family: 'Open Sans', sans-serif;
  font-weight: 600;
  color: var(--text-color);
}
```

## 5.4 Стиль кнопок
Кнопки имеют закругленные углы и плавные анимации для интерактивности.

```css
/* Основная кнопка */
.btn-primary {
  background-color: var(--button-primary);
  color: white;
  border: none;
  padding: 12px 20px;
  border-radius: 30px;
  font-size: 16px;
  cursor: pointer;
  transition: background-color 0.3s ease-in-out;
}

.btn-primary:hover {
  background-color: var(--button-hover);
}

/* Кнопка отправки */
.btn-send {
  background-color: #757575; /* Темно-серый */
  color: white;
  border: none;
  padding: 12px 20px;
  border-radius: 50%;
  font-size: 18px;
  cursor: pointer;
  transition: transform 0.2s;
}

.btn-send:hover {
  background-color: #616161; /* Более темный оттенок серого */
  transform: scale(1.1);
}
```

## 5.5 Анимации и взаимодействия
Кнопки и элементы интерфейса анимируются для улучшения взаимодействия с пользователем.

```css
/* Анимация для кнопок */
.btn-primary {
  transition: transform 0.2s ease-in-out;
}

.btn-primary:hover {
  transform: scale(1.05);
}
```

## 5.6 Мобильная адаптивность
Интерфейс приложения оптимизирован для мобильных устройств с использованием медиазапросов.

```css
/* Адаптивность для мобильных устройств */
@media (max-width: 768px) {
  .chat-window {
    max-height: 400px;
  }

  .footer {
    padding: 20px 10px;
  }

  .btn-primary {
    font-size: 14px;
    padding: 10px 16px;
  }
}
```

## 5.7 Гибкость для разных экранов
Макет будет гибким и подстраиваться под размер экрана, при этом оставаясь удобным и понятным как на мобильных устройствах, так и на десктопах.

```css
/* Основная структура */
.container {
  width: 100%;
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
}

.chat-window {
  display: flex;
  flex-direction: column;
  overflow-y: auto;
  padding: 15px;
  border-radius: 8px;
}

.footer {
  display: flex;
  justify-content: space-between;
  padding: 15px 10px;
  border-top: 1px solid #ddd;
}

.theme-toggle {
  position: absolute;
  top: 20px;
  right: 20px;
  background-color: var(--button-primary);
  padding: 10px;
  cursor: pointer;
}
```

# 6. Структура базы данных

```prisma
// This is your Prisma schema file for the entire application, including context and file embeddings.

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model Chat {
  id        String    @id @default(uuid())
  provider  String    // Тип провайдера (yandex/gigachat)
  messages  Message[] // Связь с сообщениями
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@index([provider]) // Индекс для быстрого поиска по провайдеру
}

model Message {
  id                Int      @id @default(autoincrement())
  chatId            String
  chat              Chat     @relation(fields: [chatId], references: [id])
  message           String   // Сообщение пользователя
  response          String?  // Ответ от модели
  model             String   // Используемая модель
  provider          String   // Провайдер, который сгенерировал ответ
  timestamp         DateTime @default(now())
  temperature       Float    // Параметр температуры
  maxTokens         Int      // Максимальное количество токенов
  queryEmbedding    Float[]? // Эмбеддинг запроса
  responseEmbedding Float[]? // Эмбеддинг ответа

  @@index([chatId])
  @@index([timestamp])
}

model Context {
  id               String   @id @default(uuid())
  chatId           String   // Идентификатор чата
  queryEmbedding   Float[]  // Эмбеддинг для запроса
  responseEmbedding Float[] // Эмбеддинг для ответа
  messageId        Int      // Ссылка на сообщение
  createdAt        DateTime @default(now())

  chat             Chat     @relation(fields: [chatId], references: [id])
  message          Message  @relation(fields: [messageId], references: [id])

  @@index([chatId])
  @@index([messageId])
}

model File {
  id         String   @id @default(uuid())
  userId     String   // Идентификатор пользователя
  fileName   String   // Имя файла
  fileType   String   // Тип файла
  fileUrl    String   // URL файла
  uploadedAt DateTime @default(now())
  
  user       User     @relation(fields: [userId], references: [id])
}

model FileEmbedding {
  id         String   @id @default(uuid())
  fileId     String   // Ссылка на файл
  embedding  Float[]  // Эмбеддинг для файла
  createdAt  DateTime @default(now())

  file       File     @relation(fields: [fileId], references: [id])
}

model User {
  id         String   @id @default(uuid())
  username   String   @unique
  email      String   @unique
  password   String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  files      File[]   // Связь с загруженными файлами
}
```

# 7. Описание архитектуры взаимодействия между Node.js и Python с учетом изменений

## 7.1 Node.js Backend

Node.js будет обрабатывать запросы от пользователей, управлять сессиями чатов и базовыми операциями с базой данных, включая хранение метаданных о чатах, сообщениях и контекстах. Все операции, связанные с обработкой и хранением эмбеддингов, будут делегированы Python-сервису.

### 7.1.1 Что хранить в Node.js:

1. **Чаты (Chat)**: Хранение основной информации о чате, включая:
   - `id` (UUID)
   - `provider` (тип провайдера модели)
   - `createdAt` (дата создания)
   - `updatedAt` (дата последнего обновления)

2. **Сообщения (Message)**: Хранение данных о сообщениях пользователя, включая:
   - `id` (auto-increment)
   - `chatId` (ссылка на чат)
   - `message` (сообщение пользователя)
   - `response` (ответ от модели)
   - `model` (модель, которая сгенерировала ответ)
   - `provider` (провайдер, сгенерировавший ответ)
   - `timestamp` (время отправки)
   - `temperature` (параметр генерации)
   - `maxTokens` (максимальное количество токенов)
   - `queryEmbedding` (эмбеддинг запроса)
   - `responseEmbedding` (эмбеддинг ответа)

3. **Контексты (Context)**: Хранение метаданных контекста, который включает эмбеддинги запросов и ответов. В Node.js хранятся только ссылки и метаданные контекста, а не сами эмбеддинги, так как обработка эмбеддингов происходит в Python.

### 7.1.2 Задачи Node.js:
- При получении сообщения от пользователя сохраняет его в таблице Message в базе данных.
- После сохранения данных, отправляет сообщение в Python для создания эмбеддингов.
- Управляет процессом чатов, сообщениями и пользователями.
- Отвечает за API и взаимодействие с фронтендом.

## 7.2 Python Backend

Python будет заниматься обработкой и хранением эмбеддингов, используя библиотеки и векторные базы данных, такие как FAISS. Это позволит эффективно искать релевантные контексты и сообщения для формирования ответов на запросы пользователя.

### 7.2.1 Что хранить в Python:

1. **Эмбеддинги запросов и ответов (queryEmbedding и responseEmbedding)**:
   - Эмбеддинги для сообщений пользователя и ответов модели будут храниться в векторной базе данных (например, FAISS).
   - Эмбеддинги создаются для сообщений пользователя, ответов от модели и контекстов, чтобы они могли быть использованы для быстрого поиска релевантных данных.

2. **Эмбеддинги загруженных файлов (FileEmbedding)**:
   - Все загруженные пользователем файлы отправляются на Python-сервис, где они обрабатываются и преобразуются в эмбеддинги.
   - Эмбеддинги файлов будут храниться в FAISS или другой векторной базе данных.
   - В базе данных SQL хранятся только метаданные о файлах (например, имя файла, тип, дата загрузки и т. д.).

### 7.2.2 Задачи Python:
- Обрабатывает все операции с векторизацией и хранением эмбеддингов.
- Взаимодействует с FAISS или другой векторной базой данных для хранения и извлечения эмбеддингов.
- Выполняет поиск по векторной базе данных для извлечения наиболее релевантн��х данных (контекстов и сообщений).
- Возвращает результаты поиска эмбеддингов в Node.js для дальнейшей обработки.

## 7.3 Схема взаимодействия между Node.js и Python

### 7.3.1 Node.js:
1. Когда пользователь отправляет сообщение, Node.js сохраняет его в таблице Message базы данных.
2. После этого Node.js отправляет сообщение в Python для генерации эмбеддинга.
3. После обработки эмбеддинга Python возвращает его в Node.js.
4. Node.js сохраняет эмбеддинг в таблице Context для использования в дальнейшем.
5. Node.js управляет основной логикой чатов, сообщениями и пользователями, а также взаимодействует с фронтендом и API.

### 7.3.2 Python:
1. Python обрабатывает все операции с эмбеддингами и хранением их в векторной базе данных.
2. При необходимости, Python выполняет запросы на поиск по векторной базе данных (FAISS) для нахождения наиболее релевантных контекстов и эмбеддингов.
3. После обработки данных Python возвращает результаты поиска в Node.js для отправки пользователю.

## 7.4 Пример взаимодействия:

1. **При получении сообщения**:
   - Node.js сохраняет сообщение в таблице Message.
   - Node.js отправляет сообщение в Python для генерации эмбеддинга.
   - Python генерирует эмбеддинг для сообщения и возвращает его в Node.js.
   - Node.js сохраняет эмбеддинг в таблице Context.

2. **При запросе контекста**:
   - Node.js получает запрос и ищет контекст в базе данных.
   - Node.js отправляет запрос на поиск релевантных эмбеддингов в Python через API.
   - Python выполняет поиск по векторной базе данных (FAISS) и возвращает наиболее похожие эмбеддинги.
   - Node.js отправляет пользователю релевантные данные.